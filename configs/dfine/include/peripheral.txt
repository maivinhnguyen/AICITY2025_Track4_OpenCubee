def loss_peripheral(self, outputs, targets, indices, num_boxes):
        """
        Peripheral Focus Loss (PFL) encourages accurate predictions at the peripheral (outer edge)
        regions of the object bounding boxes.
        """
        assert "pred_boxes" in outputs

        idx = self._get_src_permutation_idx(indices)
        pred_boxes = outputs["pred_boxes"][idx]  # [N, 4] in cxcywh format
        target_boxes = torch.cat([t["boxes"][i] for t, (_, i) in zip(targets, indices)], dim=0)  # [N, 4]

        # Convert from cxcywh to xyxy
        pred_boxes_xyxy = box_cxcywh_to_xyxy(pred_boxes)
        target_boxes_xyxy = box_cxcywh_to_xyxy(target_boxes)

        # Compute peripheral boxes (10% shrink from all sides)
        shrink_ratio = 0.1
        x1, y1, x2, y2 = target_boxes_xyxy.unbind(-1)
        width = (x2 - x1)
        height = (y2 - y1)

        # Shrink inward to define center zone (peripheral = outside this)
        inner_x1 = x1 + width * shrink_ratio
        inner_y1 = y1 + height * shrink_ratio
        inner_x2 = x2 - width * shrink_ratio
        inner_y2 = y2 - height * shrink_ratio

        # Define masks: peripheral areas are outside the inner box but inside the target box
        peripheral_mask = (
            (pred_boxes_xyxy[:, 0] < inner_x1) | (pred_boxes_xyxy[:, 1] < inner_y1) |
            (pred_boxes_xyxy[:, 2] > inner_x2) | (pred_boxes_xyxy[:, 3] > inner_y2)
        ).float()

        # Compute IoU between pred and target boxes
        ious, _ = box_iou(pred_boxes_xyxy, target_boxes_xyxy)
        ious_diag = torch.diag(ious).detach()

        # Apply higher weight to peripheral box misalignment
        weight = 0.5 + 0.5 * peripheral_mask  # 3x weight on peripheral prediction error

        # Use GIoU loss as base
        giou_loss = 1 - torch.diag(generalized_box_iou(pred_boxes_xyxy, target_boxes_xyxy))

        loss_periph = (giou_loss * weight).sum() / weight.sum().clamp(min=1.0)

        return {"loss_peripheral": loss_periph}